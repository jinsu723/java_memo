day16

0. 복습
1) 내부 클래스
	클래스 내부에 선언된 클래스를 의미한다
	내부 클래스 객체화는 외부 클래스가 메모리에 할당되어야만 가능하다
	내부 클래스로 선언된 클래스는 외부 클래스를 상속받지 않아도 외부 클래스 멤버 사용이 가능하다

	인스턴스 내부 클래스
	정적 내부 클래스
	로컬 내부 클래스

2) 익명 클래스
	이름이 없는 클래스
	미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해서 사용한다
	부모 클래스를 상속받는 익명 자식 객체
		new 부모생성자(매개변수){
			// 필드, 메소드(오버라이딩)
		};

	인터페이스를 구현하는 익명 구현 겍체
		해당 타입의 필드, 로컬 변수, 매개변수의 값으로 대입 가능하다
		new 인터페이스(){
			// 메소드(오버라이딩)
		}

3) 람다식 : 익명 메소드
	함수형 프로그래밍은 함수를 정의하고 이 함수를 데이터를 처리하는 쪽으로 보내 데이터를 처리하는 기법
	데이터를 처리하는 쪽에서는 데이터만 가지고 있고 처리 방법이 정해져 있지 않아 외부에서 제공된 함수에 의존한다

	java는 함수형 프로그래밍을 위해 8부터 람다식, 스트림API를 지원하고 있고
	데이터를 처리하는 쪽에 제공되는 함수역할을 하는 매개변수를 가진 중괄호 블록을 의미한다
	데이터 처리부는 람다식을 받아 매개변수에 데이터를 대입하고 중괄호를 실행시켜 처리한다

	함수형 인터페이스
	@FunctionalInterface

	함수형 인터페이스로 추상 메소드가 한 개만 선언되어 있을 때 람다식으로 재정의 가능하다
	메소드를 하나의 식으로 표현한다

	매개변수명 -> 명령문1
	(매개변수1, 매개변수2) -> {명령문; 명령문2; return 값;}

	람다식 문법
	- 매개변수가 하나인 경우 자료형 괄호 생략 가능
	- 매개변수가 두 개 이상인 경우 소괄호 생략 불가
	- 실행할 문장이 한 문장일 경우 중괄호, 세미콜론 생략 가능
	- 실행할 문장이 한 문장이라도 return문일 경우에는 {} 생략시 return 생략 가능
	  {} 생략하지 않으면 return 작성

	lambda2.FunctionalMain$$Lambda/.................
	// 람다식 객체의 문자열 표현값
	// 람다식

1. 예외처리

1) 오류의 종류
	에러(Error)	: 개발자가 해결할 수 없는 문제(코드로 수습 불가)
	예외(Exception)	: 개발자가 해결 가능한 문제(코드로 수습 가능)

2) 예외의 발생 시점
	확인된 예외(checked exception, 일반 예외)
		컴파일 단계에서 발생하는 예외(이클립스 빨간 줄)
	미확인 예외(unchecked exception, 실행 예외 Runtime Exception)
		프로그램을 실행 중(런타임) 발생하는 예외

	자바의 모든 예외 클래스는  Throwable을 상속받은 클래스로 만들어지고
	예외 클래스는 Exception 클래스를 상속받는다
	실행 예외는 RuntimeException과 해당 클래스를 상속받는 자식 클래스이고
	그 밖의 예외는 모두 일반 예외이다

3) 예외처리
	예외가 발생했을 때 프로그램이 비정상적으로 종료되는 것을 막고 정상적으로 처리하는 것을 의미한다

	try{
		예외가 예상되는 코드
	} catch(예외이름 객체명){
		예외를 처리하는 명령문
		(예외 발생시 실행할 코드)
	} catch(예외이름 객체명){
		예외를 처리하는 명령문
		(예외 발생시 실행할 코드)
	}...
	}finally{
		예외 발생 여부에 상관없이 무조건 실행할 코드
		// 생략 가능
	}

	try 블록에서 작성한 코드가 예외없이 정상 실행되면 catch 블록은 실행되지 않고 fianlly문이 실행된다
	catch문 위에서부터 검사하므로 위에서 예외가 잡히면 다른 catch문은 건너뛰고 finally문이 실행된다

4) 예외 클래스에서 제공하는 메소드
	자바에서는 발생할 수 있는 예외들을 클래스로 정의해두었다
	만약 실행중 오류가 발생하면 해당 오류 클래스의 객체가 생성(메모리에 할당된다)
	예외처리를 해두었다면 그 객체의 주소를 catch(에외 클래스 참조변수)의 참조변수가 받게된다
	예외 클래스에는 다양한 기능을 제공한다

- .getMessage() : 예외 메시지를 문자열로 반환
- .toString() : 발생한 예외 객체를 문자열로 반환
		생략 가능, 참조변수를 출력하면 자동으로 toString()가 사용됨
- .printStackTrace() : 예외가 발생지점을 추적하여 단계별로 전부 출력함

	=> 예외처리를 적절하게 수행하면 프로그램의 안정성을 높이고, 신뢰성 있는 프로그램을 만들 수 있다

5) throws와 throw
	메소드 내부에서 예외가 발생할 때 try-catch 블록으로 예외를 처리하는 것이 기본이지만 메소드를 호출하는 곳으로
	예외처리를 떠넘길 수 있다

- throws : 예외 던지기, 메소드의 선언부에 사용한다
	메소드에서 발생할 수 있는 오류를 메소드를 정의할 때 처리하지 않고
	해당 메소드를 사용하는 쪽으로 던져서 메소드를 사용하는 개발자가 처리하도록 한다
	(상황에 맞게 예외처리하기 위함)
	ex) void method1() throws 예외클래스명 {}
	    void method1() throws 예외클래스명, 예외클래스명 {}
- throw : 예외를 발생시킨다(강제 예외 발생시키기)
	ex) throw new 예외명();

=> try{}catch(예외클래스명 참조변수){}
	참조변수.printStackTrace()
	참조변수.toString()
	참조변수.getMessage()

=> throws	예외 던지기, 메소드 선언부에 작성
=> throw	예외 강제로 발생시키기

6) 사용자 정의 예외
	사용자 정의 예외는 컴파일러가 체크하는 일반 예외로 선언할 수도 있고,
	컴파일러가 체크하지 않는 실행 예외로 선언할 수도 있다

	일반 예외 Exception 클래스를 상속받는 자식 클래스로 선언하고
	실행 예외는 RuntimeException 클래스를 상속받는 자식 클래스로 선언한다

	기본 생성자와 예외 메시지를 입력받는 생성자를 선언해주거나 super()에 예외 메시지를 전달한다

	public class 예외명 extends Exception or RuntimeException{
		생성자(){
			super("사용자정의예외메시지");
		}
	}

2. API(Application Programing Interface)
	응용 프로그래밍 인터페이스

	내부 API
		JDK(JRE, JVM) 설치 시 제공해주는 기본 api
		자바로 어플리케이션을 쉽게 구현할 수 있도록 한 라이브러리 집합
		https://docs.oracle.com/en/java/javase/17/docs/api/index.html

	외부 API
		다른 개발자들이 개발한 패키지 및 클래스들을 의미한다
		보통 jar 파일로 배포하며 자바 프로젝트에 build path에 추가하여 사용할 수 있다

1) API 공식문서 확인
	- 전체 상속관계를 보려면 상속 계층도를 보면 된다
	- api 도큐먼트에서 String 클래스가 어떻게 정의되어 있는지는 아래쪽에 있는 선언부를 보면 된다
		클래스가 final인지 추상 클래스인지 알 수 있고, 부모 클래스나 구현 인터페이스도 볼 수 있다
	- 구현멤버는 상단 메뉴에 SUMMARY를 보면 된다
		멤버별로 링크를 제공하는데 링크가 있으면 public, protected 공개된 멤버가 있다는 의미이고
		링크가 없으면 공개된 멤버가 없다는 뜻이다

2) 모듈, 패키지, 라이브러리
- 모듈(Module)
	자바 9부터 도입된 시스템
	코드를 논리적으로 그룹화하고 모듈간의 의존성을 관리하는 방법을 제공한다
	모듈은 패키지와 라이브러리의 개념을 확장하고 런타임에서 모듈의 논리적인 단위로 코드를 로드하고 관리할 수 있다
	코드의 의존성을 더욱 명확하게 정의하고 런타임 모듈 시스템을 통해 더 격리된 환경을 제공한다

- 패키지(Package)
	관련된 클래스 및 인터페이스를 그룹화 하는 방법을 제공한다
	패키지는 디렉토리 주소와 일치하고 패키지 내의 클래스들은 동일한 패키지 이름 공간 안에 있어야 한다
	코드를 구조화하고 이름 충돌을 방지하는 데 도움을 준다

- 라이브러리(Library)
	jar(Java Archive) 압축파일 형태로 존재한다 jar파일에는 클래스와 인터페이스의 바이트코드(.class)파일들이 압축
	재사용 가능한 코드 집합
	특정 작업 또는 기능을 수행하기 위해 다른 프로그램에서 사용할 수 있게 해준다

3) 외부 API
	JAR 파일로 만든다
	Java Archive : java 클래스파일, 리소스 파일 및 메타데이터를 포함하는 아카이브 파일

- Jar 파일 생성
	java 어플리케이션을 개발한 모든 파일들을 Jar 파일로 패키징

- Jar 파일 베포
	jar파일을 웹사이틀, FIP 서버, 클라우드 저장소 들에 업로드하여 베포 가능

- Jar 파일 실행
	jar파일을 실행하려면 Java Runtime Enviroment(JRE)가 필요하다
	java - jar [jar 파일명]

Jar 파일 베포
	베포할 클래스, 패키지 마우스 우클릭 > Export > JAVA/JAR file 선택 > Next
	> Destination 원하는 경로로 선택 > Export Java Source files .. 체크(API 주석 포함하겠다)
	> Finish

외부 API Build Path에 추가
	배포된 jar 파일 다운로드 > 프로젝트 우클릭 > Build Path > Configure Build Path
	> Libraries 탭 클릭 > Add External JARs 클릭 > 저장된 경로의 .jar파일을 더블 클릭으로 추가 > Apply 클릭
	> Orders and Exports 탭 클릭 > Select All 클릭 > Apply and Close 클릭

3. Stream API
	Java 8에서 도입된 기능
	함수형 프로그래밍을 지원하며 데이터의 흐름을 기반으로 하는 API
	컬렉션 데이터를 효과적으로 처리하고 조작하는 데 사용된다
	데이터를 선언적으로 처리할 수 있다

+) 선언적 언어	VS	 명령적 언어
		선언적				명령적
초점		무엇을 해야 하는지 정의		어떻게 해야 하는지 정의
코드 작성		간결하고 읽기 쉬움			절차적이고 복잡해질 수 있음
제어 흐름		실행 방법은 추상화			실행 벙법을 상세히 기술
예시		Stream API, SQL, HTML, CSS	for, 조건문, ..

1) 스트림(Stream)
	데이터의 흐름을 추상화 한 것, 배열, 컬렉션, I/O 자원에서 데이터를 저리하기 위한 API
	데이터를 한 번만 소비, 기존 데이터 원본을 변경하지 않음

2) 스트림 연산
- 증감 연산 : 스트림을 반환하는 작업, 결과가 또 다른 스트림으로 반환됨
	지연실행(Lazy Evaluation) : 최종 연산이 호출 될 때만 실행
	연속적으로 연결 가능(메소드 체이닝)
	filter(조건)	: 조건에 맞는 요소만 남김
	map(함수)	: 각 요소를 변환
	sorted()	: 요소를 정렬
	distinct()	: 중복 요소 제거
	limit(long)	: 처음 n개 요소만 가져옴
	skip()		: 처음 n개 요소를 건너뜀
- 최종 연산 : 스트림을 처리하고 결과를 반환하거나 출력하는 작업
	스트림 파이프라인의 끝을 나타냄
	최종 연산 후 스트림은 더 이상 사용 불가능

	collect(Collector) : 스트림의 결과를 컬렉션 등으로 반환
	forEach(Consumer) : 각 요소를 소비 => forEach(System.out::println)
	count() : 요소의 개수를 반환
	reduce(BinaryOperator) : 스트림 요소를 누적

+) 메소드 참조
	기존 메소드를 간결하게 호출하기 위한 표현식
	ClassName::staticMethod
	ObjectName::instanceMethod
	ClassName::new(생성자참조)

3) 스트림 소스(Source)
	스트림을 생성하는 데이터 원본

	배열 : Arrays.stream(array)
	컬랙션 : List.stream(), Set.stream()
	숫자 범위 : IntStream.range(1, 10)

4. Object 클래스
	java.base 모듈
	java.lang 패키지
		Object 클래스	자바 클래스 최상위 클래스 사용
		System		키보드로부터 데이터를 입력 받기 위해 사용
				모니터(콘솔)로 출력하기 위해 사용
				프로세스 종료시킬 때 사용
				진행시간을 읽을 때 사용
				시스템 속성(프롬프터)을 읽을 때 사용
	문자열 관련 String		문자열을 저장하고 조작할 때 사용
		StringBuilder	효율적인 문자열 조작기능이 필요할 때 사용
	포장 관련	Byte, Short,	기본 타입의 값을 포장할 때 사용
		Integer, Double,	문자열을 기본 타입으로 변환할 때 사용
		...
		Math		수학 계산이 필요할 때 사용
		Class		클래스의 메타 정보(이름, 구성 멤배) 등을 조사할 때 사용

1) Object 클래스
	모든 클래스의 최상위 부모 클래스

	boolean equals(Object obj)	객체의 번지(주소값)를 비교하고 결과를 리턴
	int hashCode()			객체의 해시코드를 리턴
	String toString()		객체 문자 정보를 리턴

2) toString()
	object의 toString()은 참조값을 문자열 형태로 줄력한다
	참조변수를 print()등의 출력 메소드로 출력하면 항상 toString()이 사용된다 => 참조값이 나오는 이유
	toString()을 통해 출력되는 문자열을 바꾸고 싶다면 재정의해서 사용한다

Object의 toString()

public Stirng.toString() {

return getClass().getName

Exception의 toString()

	public String toString() {
		String s = getClass().getName();
		String message = getLocalizeMessage();
		return (message != null) ? (s + ": " + message) : s;
	}

	주소값 : hashCode()	-> 메모리상의 주소값을 특정 알고리즘을 통해 정수값으로 반환한다
		toHexString(hashCode()); -> 16진수로 변환된(해쉬코드)값. 해쉬값이라고 한다